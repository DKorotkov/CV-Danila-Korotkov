(function () {
   ("use strict");

   // -------------Загрузка шрифтов через скрипт------------
   //----------------------------ШРИФТЫ------------------------------------------------------------
var mainFont = new FontFaceObserver("LyuLin");
// var Raleway = new FontFaceObserver("Raleway");

// // Загружаем все шрифты сразу Здесь лучше загружать шрифты, которые не являются основными, но находяться в верхней части страницы.
// Promise.all([Montserrat.load()]).then(function () {
//    console.log("Montserrat загружен");
// });

// Добавлем необходимые классы при загрузке нужного шрифта
var html = document.documentElement;

if (html.classList.contains("fonts-loading")) {
   mainFont
      .load()
      .then(function () {
         html.classList.remove("fonts-loading");
         html.classList.add("fonts-loaded");
         sessionStorage.fontsLoaded = true; // Загружаем в кэш
      })
      .catch(function () {
         html.classList.remove("fonts-loading");
         html.classList.add("fonts-failed");
         sessionStorage.fontsLoaded = false;
      });
}

// Здесь лучше загружать шрифты которые не основные и находяться в нижней части страницы
// Montserrat.load().then(function () {
//    console.log("Загружен Input Mono");
// });
// ________________________________________________________________________________________________________________

   // ------------------------------------------------------

   // --------------------------------Загузка класса Аккардион----------------------------
   // include('modules/_accordion.js')
   // ------------------------------------------------------------------------------------

   // --------------------------------Загрузка класса Валидации форм----------------------
   // Для валидации формы на сайте
class FormValid {
   constructor(options) {
      this.constructorOptions = options;
      this.init();
   }

   static init() {
      const defaultOptions = {
         formClassName: "form",
         errorClassName: "error",
         inputClassName: "form__input",
         invalidClassName: "invalid",
         withValueClassName: "not-empty",
         errors: {
            required: "Заполните обязательное поле",
            email: "Пожалуйста, введите правильный email",
            type: "Не соответствует формату поля",
            pattern: "Не соответствует формату поля",
            tooShort: "Слишком короткое",
            tooLong: "Слишком динное",
            stepMismatch: "Неверный шаг (введенный диапозон)",
            rangeUnderflow: "Меньше диапозона",
            rangeOverflow: "Больше диапозона",
            customError: "Ошибка",
            badInput: "badInput",
         },
      };
      this.options = Object.assign(defaultOptions, this.constructorOptions);

      this.forms = document.querySelectorAll("form");
      if (!this.forms) console.error("Форма на странице не найдена");

      this.forms.forEach((form) => {
         // form.setAttribute("novalidate", "");
         let inputs = [...form.querySelectorAll("input")];
         const textarea = [...form.querySelectorAll("textarea")];
         inputs = inputs.concat(textarea);
         inputs.forEach((input) => {
            // Добавялем елемент для вывода ошибок
            const error = document.createElement("span");
            error.classList.add(`${this.options.formClassName}__${this.options.errorClassName}`);
            error.setAttribute("aria-live", "polite");
            input.insertAdjacentElement("afterend", error);

            input.addEventListener("blur", (e) => {
               this.validate(e);
               this.isEmpty(e);
            });
         });

         form.addEventListener("submit", (e) => {
            this.checkValid(e);
         });
      });
   }

   // Проверяем пустое ли поле
   static isEmpty(input) {
      if (input.target) input = input.target;
      if (input.value.length > 0) input.classList.add(`${this.options.inputClassName}--${this.options.withValueClassName}`);
      else input.classList.remove(`${this.options.inputClassName}--${this.options.withValueClassName}`);
   }

   // Проверяем поля на валидацию
   static validate(input) {
      if (input.target) input = input.target;
      const error = input.nextElementSibling;
      // const inputType = input.getAttribute("type");
      // let pattern = input.getAttribute("pattern");

      if (!input.validity.valid) {
         // Проверка на обязательное поле
         if (input.validity.valueMissing) {
            this.setInvalid(input, this.options.errors.required);
            return error;
         }
         // Проверка по типу
         if (input.validity.typeMismatch) {
            this.setInvalid(input, this.options.errors.type);
            return error;
         }
         // Проверка по паттерну
         if (input.validity.patternMismatch) {
            this.setInvalid(input, this.options.errors.pattern);
            return error;
         }
         // Проверка слишком короткое
         if (input.validity.tooShort) {
            this.setInvalid(input, this.options.errors.tooShort);
            return error;
         }
         // Проверка слишком короткое
         if (input.validity.tooLong) {
            this.setInvalid(input, this.options.errors.tooLong);
            return error;
         }
         // Проверка слишком короткое
         if (input.validity.stepMismatch) {
            this.setInvalid(input, this.options.errors.stepMismatch);
            return error;
         }
         // Проверка меньше диапозона
         if (input.validity.rangeUnderflow) {
            this.setInvalid(input, this.options.errors.rangeUnderflow);
            return error;
         }
         // Проверка больше диапозона
         if (input.validity.rangeOverflow) {
            this.setInvalid(input, this.options.errors.rangeOverflow);
            return error;
         }
         // Проверка кастомная ошибка
         if (input.validity.customError) {
            this.setInvalid(input, this.options.errors.customError);
            return error;
         }
         // Проверка badInput
         if (input.validity.badInput) {
            this.setInvalid(input, this.options.errors.badInput);
            return error;
         }
      }

      input.classList.remove(`${this.options.inputClassName}--${this.options.invalidClassName}`);
      error.innerHTML = "";
   }

   // Сообщаем об ошибке валидации
   static setInvalid(input, text) {
      const error = input.nextElementSibling;
      input.classList.add(`${this.options.inputClassName}--${this.options.invalidClassName}`);
      error.innerHTML = text;
   }

   // Проверят поля перед отправкой, в случае, если по ним не проходили или не заметили ошибку
   static checkValid(e) {
      let errorElements = new Array();
      const form = typeof e.currentTarget === "object" ? e.currentTarget : e;
      const inputs = form.querySelectorAll("input");

      if (typeof e.currentTarget === "object") e.preventDefault();
      inputs.forEach((input) => {
         errorElements.push(this.validate(input));
      });

      errorElements = errorElements.filter(function (element) {
         return element !== undefined;
      });

      if (errorElements.length === 0) {
         // form.submit();
         return true;
      }

      errorElements[0].previousSibling.focus();
   }
}

// -----------Проверка валидация формы-------------------
FormValid.init();
// ------------------------------------------------------

// Вынести этот модуль ввиде отдельного проекта, вывести на гитхаб с описанием

// -----------Пример работы с кнопкой формы отправки без submit----------------
// const submitBtns = document.querySelectorAll(".appointment-form__submit");
// submitBtns.forEach((submitBtn) => {
//    submitBtn.addEventListener("click", (e) => {
//       const thisForm = e.currentTarget.closest("form");
//       if (FormValid.checkValid(thisForm)) {
//          console.log("Отправляем форму");
//       }
//    });
// });

   // ------------------------------------------------------------------------------------

   // --------------------------------Загрузка класса Событий "касаний"----------------------
   // include('modules/_eventTouch.js')
   // ------------------------------------------------------------------------------------

   // --------------------------------Загрузка класса "Общего класса"----------------------
   /**
 * Общий класс для работы с модулями DK
 *
 *
 */

class NodaDK {
   _KEYS = {
      ESC: 27,
      SPACE: 32,
      ENTER: 13,
      TAB: 9,
      ARROW_LEFT: 37,
      ARROW_UP: 38,
      ARROW_RIGHT: 39,
      ARROW_DOWN: 40,
   };
   #focusableElements = 'a[href]:not([disabled]), button:not([disabled]), textarea:not([disabled]), input:not([disabled]), select:not([disabled]), select, details, audio, video, object, [contenteditable=""], [contenteditable="true"], [tabindex]:not([tabindex="-1"])';
   #defaultOptions = {
      focusTrap: false,
      collapseOnFocusOut: false,
   };

   // #destroyed = false; // Храним информации о том уничтежен ли объект

   constructor(options) {
      this._options = Object.assign(this.#defaultOptions, options);
      this._$el = document.querySelector(this._options.selector);
      if (this.#check()) this.#init();
      else this._hasErrors = true;
   }

   #check() {
      if (!this._$el) {
         console.error(`Не найден класс - ${this._options.selector}`);
         return false;
      }
      // Проверяет на соответсвие к медиа запросу
      if (typeof this._options.matchMedia !== "undefined" && !window.matchMedia(this._options.matchMedia).matches) {
         return false;
      }
      return true;
   }

   #init() {
      this._$el.addEventListener("click", (e) => this._mainElClick(e));
      this._$el.addEventListener("keydown", (e) => this._checkPress(e), true);
   }

   _initFocusableContent() {
      this._$lastFocusableEl = this._$el.querySelector('[data-select-last="true"]');
      this._getFocusableContent();

      // Последний элемент который будет в фокусе
      if (this._$lastFocusableEl) this._$lastFocusableEl.tabIndex = -1;
      // Удаляем этот элемент (который последний в фокусе) из спсика всех элементов фокуса
      this._$focusableContent = this._$focusableContent.filter((el) => {
         if (el !== this._$lastFocusableEl) return el;
      });
   }

   #focusTrapAndCollapse(e) {
      const firstFocusableEl = this._$focusableContent[0];
      const lastFocusableEl = this._$focusableContent[this._$focusableContent.length - 1];
      const needLastFocusableEl = this._$lastFocusableEl;

      if (e.shiftKey) {
         /* shift + tab */ if (document.activeElement === firstFocusableEl || document.activeElement === needLastFocusableEl) {
            if (needLastFocusableEl && document.activeElement !== needLastFocusableEl && !this._options.collapseOnFocusOut) needLastFocusableEl.focus();
            else {
               if (this._options.collapseOnFocusOut) this.close();
               lastFocusableEl.focus();
            }
            e.preventDefault();
         }
      } /* tab */ else {
         if (document.activeElement === lastFocusableEl || document.activeElement === needLastFocusableEl) {
            if (needLastFocusableEl && document.activeElement !== needLastFocusableEl) needLastFocusableEl.focus();
            else {
               if (this._options.collapseOnFocusOut) this.close();
               firstFocusableEl.focus();
            }
            e.preventDefault();
         }
      }
   }

   _checkPress(e) {
      if (e.keyCode === this._KEYS.ESC) this.close();

      // Если требуется захватить фокус на элементе
      if (e.key === "Tab" || e.keyCode === this._KEYS.TAB) {
         if (this._options.focusTrap || this._options.collapseOnFocusOut) this.#focusTrapAndCollapse(e);
      }
   }

   _mainElClick(e) {
      // Если по кнопке закрытия
      if (e.target.closest('[data-close="true"]') || e.target.dataset.close) {
         this.close();
      }
   }

   _getFocusableContent() {
      this._$focusableContent = [...this._$el.querySelectorAll(this.#focusableElements)];
   }

   open() {
      // if (this.#destroyed) return console.error(`Объект с классом - ${this._options.selector} уничтожен и не может быть "Открыт"`);
      if (this._options.activeClass) this._$el.classList.add(this._options.selector.slice(1) + this._options.activeClass);
      else this._$el.removeAttribute("hidden");

      if (typeof this._$focusableContent === "undefined") this._initFocusableContent();

      // Для запрета прокрутки основного контента
      window.disableScroll();
      // document.body.style.overflow = "hidden";
   }

   close() {
      if (this._options.activeClass) this._$el.classList.remove(this._options.selector.slice(1) + this._options.activeClass);
      else this._$el.setAttribute("hidden", "");
      this.destroy();

      // Для прокрутки основного контента
      // document.body.style.overflow = "";
   }

   destroy() {
      this._$el.removeEventListener("click", (e) => this._mainElClick(e));
      this._$el.removeEventListener("keydown", (e) => this._checkPress(e), true);
      window.enableScroll();
      // this.#destroyed = true;
   }
}

/**
 *  ПРАВИЛА ПО СОЗДАНИЮ МОДУЛЯ
 *
 * 1. Использовать вместо селектро готовый объект. Это значит, что на вход
 * необходимо получать:
 * const el = document.qeurySelect(".el")
 *
 * const noda = New NodaDK(el, {options});
 *
 * 2. Если в процессе работы модуля создается новая нода в html, то необходимо
 * ее создавать каждый раз при открытии и удалять при закрытии, включая все
 * event Listners
 *
 * 3. Разделять функции по направляению или элемента
 */

/**
 *
 * TODO:
 * 1. переделать вывод ошибок через throw New Error
 */

function isTouchDevice() {
   return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
}

   // ------------------------------------------------------------------------------------

   // --------------------------------Загрузка класса "Модальных окон"----------------------
   /*

   Появляеющиеся модальное окно (эффекты появления настраиваются дополнительно).
   Возможно использовать для основной навгиации на сайте и любых других меню или модальных окон.
   
   !нет реализации! data-select-first="true" - необходимо установить на элемент, который должн попасть в фокус при открытии модального окна
   

   data-select-last="true" - необходимо установить на элемент, который должн попасть в фокус в самый последний момент
   data-close="true" - необходимо установить на элемент, который будет закрывать модальное окно (только на элементы внутри окна)


   Объект модального окна:
   selector - селектор модального окна с которым будем работать
   openBtnsSelector - кнопки открытия (могут быть указаны ввиде массива)
   contentClass - класс, который используется для обертки содержимого "content",
   matchMedia - медиа запрос, в котором должен запускаться новый класс (none)
   dialogFullScreen - указывает открывать ли диалог (dialog) на весь экарн (default: true)

   focusTrap - требуется ли переходить табом только по модальному окну (default: false) не работает с collapseOnFocusOut = true 
   collapseOnFocusOut - требуется ли закрывать окно при потери фокуса (default: false)
   
   overlay - требуется ли оверлей (default: true)
   ovarlayClass - класс для оверлэя (default: "ovarlay")
   overlayBg - цвет bg (defult: "rgba(0,0,0, 0.5)")

   onOpen() - Функция при открытии
   onClose() - Функция при закрытии
   
   modal = new ModalDK({
      selector: "#modal",
      openBtnsSelector: [".btn--open"],
      contentClass: "content",
      mathcMedia: '(max-width: 50rem)',
      dialogFullScreen: true,
      focusTrap: true, // Требуется ли перемещаться табом только внутри объекта (default: false)
      collapseOnFocusOut: true, // Требуется ли закрывать при потери фокуса
      ovarlayClass: "overlay",
      overlay: true,
      overlayBg: "rgba(0,0,0, 0.5)",
      onOpen() {
         console.log("modal opening");
      },
      onClose() {
         console.log("modal closing");
      },
   });

   Реализация в html для dialog
   <dialog class="modal" id="modal">
      <button class="btn-modal-close" data-close="true">х</button>
      <p>Это модальное окно</p>
   </dialog>

   Реализация в html 
   <div class="modal" id="modal" hidden>
      <button class="btn-modal-close" data-close="true">х</button>
      <p>Это модальное окно</p>
   </div>
    

   TODO:
   Когда добавлю aria атрибуты, то использовать их вместо класса active
   aria указывать что окно появилось
*/

class ModalDK extends NodaDK {
   #defaultOptions = {
      dialogFullScreen: true,
      contentClass: "content",
      overlay: true,
      ovarlayClass: "overlay",
      overlayBg: "rgba(0,0,0, 0.5)",
   };
   #$activeOpenBtn; // Храним ноду кнопки, которой открыли, для перевода на нее фокусе, когд закроем окно
   constructor(options) {
      super(options);
      if (this.#check()) {
         this._options = Object.assign(this.#defaultOptions, this._options);
         this._$openBtns = document.querySelectorAll(this._options.openBtnsSelector);

         this.#init();
      }
   }

   #check() {
      return !this._hasErrors;
   }

   #init() {
      if (this._$el.nodeName !== "DIALOG") {
         this._$el.setAttribute("role", "dialog");
         this._$el.setAttribute("aria-modal", "true");
         this._$el.setAttribute("aria-hidden", "true");
      }

      // Добавялем элемент обертку (content)
      const content = document.createElement("div");
      content.classList.add(`${this._options.selector.slice(1)}__${this._options.contentClass}`);
      content.innerHTML = this._$el.innerHTML;
      this._$el.innerHTML = "";
      this._$el.appendChild(content);

      // Добавляем оверлей
      if (this._options.overlay && this._$el.nodeName !== "DIALOG") {
         const overlay = document.createElement("div");

         overlay.style.backgroundColor = this._options.overlayBg;
         overlay.style.position = "fixed";
         overlay.style.inset = "0";
         overlay.classList.add(this._options.selector.slice(1) + "__" + this._options.ovarlayClass);
         overlay.addEventListener("click", this.close.bind(this));
         if (this._$el.querySelector(":first-child").style.position === "static") this._$el.querySelector(":first-child").style.position = "relative";
         this._$el.insertBefore(overlay, this._$el.firstChild);
      }

      if (this._$openBtns) {
         // События
         this._$openBtns.forEach((openBtn) => {
            openBtn.setAttribute("aria-haspopup", "dialog");
            openBtn.addEventListener("click", this.open.bind(this));
         });
      }
   }

   _mainElClick(e) {
      super._mainElClick(e);
      if (e.target.nodeName === "DIALOG") {
         this.close();
         return;
      }
   }

   open() {
      setTimeout(() => {
         if (this._$el.getAttribute("aria-hidden") === "false" || this._$el.hasAttribute("open")) {
            this.close();
            return;
         }
         this.#$activeOpenBtn = document.activeElement;

         if (this._$el.nodeName === "DIALOG") {
            if (this._options.dialogFullScreen) this._$el.showModal();
            else this._$el.show();
         } else {
            super.open();
            this._$el.setAttribute("aria-hidden", "false");
         }

         if (this._$focusableContent.length > 0) this._$focusableContent[0].focus();
         if (typeof this._options.onOpen === "function") this._options.onOpen();
         // setTimeout(() => {

         // }, 1);
      }, 1);
   }

   close() {
      this._$el.setAttribute("closing", "");
      const _$elLsAnim = this._$el.nodeName === "DIALOG" ? this._$el : this._$el.querySelector(`.${this._options.selector.slice(1)}__${this._options.contentClass}`);
      if (_$elLsAnim.getAnimations().length === 0) {
         console.error(`Необходимо добавить анимацию для`, _$elLsAnim);
         this.#closing();
      } else {
         _$elLsAnim.addEventListener(
            "animationend",
            () => {
               this.#closing();
            },
            { once: true }
         );
      }

      setTimeout(() => {
         if (this.#$activeOpenBtn.tabIndex !== -1) this.#$activeOpenBtn.focus();
         if (typeof this._options.onClose === "function") this._options.onClose();
      }, 1);

      // document.querySelector("main").removeAttribute("inert", "");
   }

   #closing() {
      this._$el.removeAttribute("closing");
      if (this._$el.nodeName === "DIALOG") {
         this._$el.close();
         super.destroy();
      } else {
         this._$el.setAttribute("aria-hidden", "true");
         super.close();
      }
   }
}

   // ------------------------------------------------------------------------------------
   // --------------------------------Загрузка класса "Вкладок (табов)"----------------------
   //  include('modules/_tabs.js')
   // ------------------------------------------------------------------------------------

   // --------------------------------Загрузка класса "Запрета прокрутки"----------------------
   // // left: 37, up: 38, right: 39, down: 40,
// // spacebar: 32, pageup: 33, pagedown: 34, end: 35, home: 36
// var keys = { 37: 1, 38: 1, 39: 1, 40: 1 };

function scrollPreventDefault(e) {
   e.preventDefault();
}

// function preventDefaultForScrollKeys(e) {
//    if (keys[e.keyCode]) {
//       preventDefault(e);
//       return false;
//    }
// }

// modern Chrome requires { passive: false } when adding event
let supportsPassive = false;
try {
   window.addEventListener(
      "test",
      null,
      Object.defineProperty({}, "passive", {
         get: function () {
            supportsPassive = true;
         },
      })
   );
} catch (e) {}

const wheelOpt = supportsPassive ? { passive: false } : false;
const wheelEvent = "onwheel" in document.createElement("div") ? "wheel" : "mousewheel";

// call this to Disable
window.disableScroll = () => {
   window.addEventListener("DOMMouseScroll", scrollPreventDefault, false); // older FF
   window.addEventListener(wheelEvent, scrollPreventDefault, wheelOpt); // modern desktop
   window.addEventListener("touchmove", scrollPreventDefault, wheelOpt); // mobile
   // window.addEventListener("keydown", scrollPreventDefaultForScrollKeys, false);
};

// call this to Enable
window.enableScroll = () => {
   window.removeEventListener("DOMMouseScroll", scrollPreventDefault, false);
   window.removeEventListener(wheelEvent, scrollPreventDefault, wheelOpt);
   window.removeEventListener("touchmove", scrollPreventDefault, wheelOpt);
   // window.removeEventListener("keydown", scrollPreventDefaultForScrollKeys, false);
};

// class DisableScroll {
//    constructor() {
//       this.supportsPassive = false;
//       this.init();
//    }

//    init() {
//       try {
//          window.addEventListener(
//             "test",
//             null,
//             Object.defineProperty({}, "passive", {
//                get: function () {
//                   this.supportsPassive = true;
//                },
//             })
//          );
//       } catch (e) {}

//       this.wheelOpt = this.supportsPassive ? { passive: false } : false;
//       this.wheelEvent = "onwheel" in document.createElement("div") ? "wheel" : "mousewheel";
//    }

//    preventDefault(e) {
//       e.preventDefault();
//    }

//    // call this to Disable
//    disable() {
//       console.log(this.supportsPassive);
//       window.addEventListener("DOMMouseScroll", this.preventDefault, false); // older FF
//       window.addEventListener(this.wheelEvent, this.preventDefault, this.wheelOpt); // modern desktop
//       window.addEventListener("touchmove", this.preventDefault, this.wheelOpt); // mobile
//       // window.addEventListener("keydown", this.preventDefaultForScrollKeys, false);
//    }

//    // call this to Enable
//    enable() {
//       window.removeEventListener("DOMMouseScroll", this.preventDefault, false);
//       window.removeEventListener(this.wheelEvent, this.preventDefault, this.wheelOpt);
//       window.removeEventListener("touchmove", this.preventDefault, this.wheelOpt);
//       // window.removeEventListener("keydown", this.preventDefaultForScrollKeys, false);
//    }
// }

// const disableScroll = new DisableScroll();

   // ------------------------------------------------------------------------------------

   // --------------------------------Загрузка класса "Галереи"----------------------
   // // ---------------------------Галерея изображений-----------------------------------
/**
 *
 *
 * data-gallery - для передачи больших изображений
 * 
 * Объект:
   selector - селектор с которым будем работать
   openBtnsSelector - кнопки открытия (могут быть указаны ввиде массива)
   closeBtnsSelector: - кнопки закрытия (могут быть указаны ввиде массива)
   description - требуется ли выводить описсание из тэга alt (true)
   imgsList - трбуется ли создавать список изображений (true)
   matchMedia - медиа запрос, в котором должен запускаться новый класс (none)

   data-close="true" - необходимо установить на элемент, который будет закрывать модальное окно (только на элементы внутри окна)
   data-select-last="true" - необходимо установить на элемент, который должн попасть в фокус в самый последний момент
   data-gallery="http://localhost:3000/img/cert/1-1.jpg" - ссылка на файл, большого размера

   g = new GalleryDK({
      selector: ".gallery", // селектор контейнера, который объединяет все изображения
      focusTrap: true,
      collapseOnFocusOut: false,
   });

   * TODO:
   * ?Добавить знак загрузки
   * ?При двойном нажатии увеличивать в точке нажатия

 */
class GalleryDK extends NodaDK {
   #defaultOptions = {
      description: true,
      imgsList: true,
   };
   #activeImgNum;
   #elPadding;
   #ANIMTAION_TIME = 300;
   #tapedTwice = false;

   constructor(options) {
      super(options);
      if (this.#check()) {
         this._options = Object.assign(this.#defaultOptions, this._options);
         this._$originalImgs = [...this._$el.querySelectorAll("img")];
         this.#init();
      }
   }

   #check() {
      return !this._hasErrors;
   }

   #init() {
      // Проходим по оригинальным изображениям
      this._$originalImgs.map((img, i) => {
         img.style.cursor = "zoom-in";
         img.setAttribute("data-id", i);
      });
   }

   #initOnOpen() {
      this.#createGallery();
      this.#elPadding = parseInt(getComputedStyle(this._$el).getPropertyValue("padding-left"));

      this._$galleryMainImg = this._$el.querySelector(".gallery-dk__img");
      this._$imgPreviewList = [...this._$el.querySelectorAll("[data-id]")];
      super._getFocusableContent();

      this._onTouchStart = this._onTouchStart.bind(this);
      this._onTouchEnd = this._onTouchEnd.bind(this);
      this._onTouchMove = this._onTouchMove.bind(this);

      this.#initTouchListners();
   }

   #initTouchListners() {
      // this._$galleryMainImg.addEventListener("pointerdown", this._onTouchStart);
      // this._$galleryMainImg.addEventListener("pointerup", this._onTouchEnd);
      // this._$galleryMainImg.addEventListener("pointermove", this._onTouchMove);
      this._$galleryMainImg.addEventListener("touchstart", this._onTouchStart);
      this._$galleryMainImg.addEventListener("touchend", this._onTouchEnd);
      this._$galleryMainImg.addEventListener("touchmove", this._onTouchMove);
   }

   #destroyTouchListners() {
      this._$galleryMainImg.removeEventListener("touchstart", this._onTouchStart);
      this._$galleryMainImg.removeEventListener("touchend", this._onTouchEnd);
      this._$galleryMainImg.removeEventListener("touchmove", this._onTouchMove);
   }

   #createGallery() {
      // Создаем галерею
      const $galleryDK = document.createElement("div");
      $galleryDK.classList.add("gallery-dk");
      if (!this._options.imgsList) $galleryDK.classList.add("gallery-dk--no-list");
      $galleryDK.setAttribute("hidden", "");
      $galleryDK.setAttribute("aria-live", "polite");
      $galleryDK.innerHTML = this.#getTemaplate();
      this._$el.insertAdjacentElement("beforeend", $galleryDK);

      const $imgsList = $galleryDK.querySelector(".gallery-dk__list");
      // Проходим по оригинальным изображениям
      this._$originalImgs.map((img, i) => {
         if (this._options.imgsList) {
            // Добавляем изображения
            const imgPreview = img.cloneNode(true);
            imgPreview.removeAttribute("class");
            imgPreview.removeAttribute("style");

            imgPreview.setAttribute("data-id", i);
            imgPreview.setAttribute("aria-selected", "false");
            imgPreview.tabIndex = 0;
            // imgPreview.addEventListener("click", (e) => {
            //    this.setImg(i);
            // });
            $imgsList.appendChild(imgPreview);
         }
      });

      this._$el = $galleryDK;
   }

   #getTemaplate() {
      const descriptionClipped = this._options.description ? "" : "clipped";
      const list = this._options.imgsList ? '<ul class="gallery-dk__list" role="list"></ul>' : "";
      return `<div class="gallery-dk__btns-wrapper">
                  <button class="gallery-dk__to-left" data-prev="true" aria-label="предыдущее изображение"></button>
                  <button class="gallery-dk__to-right" data-next="true"  aria-label="следующее изображение"></button>
                  <button class="gallery-dk__zoom" data-zoom="true" aria-label="увеличить изображение">

                    <?xml version="1.0" ?><svg class="gallery-dk__zoom-svg" data-zoom="true" enable-background="new 0 0 32 32" id="Editable-line" version="1.1" viewBox="0 0 32 32" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><circle cx="14" cy="14" fill="none" id="XMLID_94_" r="9"  stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2"/><line fill="none" id="XMLID_93_"  stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2" x1="27" x2="20.366" y1="27" y2="20.366"/><line fill="none" id="XMLID_96_"  stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2" x1="14" x2="14" y1="10" y2="18"/><line fill="none" id="XMLID_97_"  stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2" x1="10" x2="18" y1="14" y2="14"/></svg>

                  </button>
                  <button class="gallery-dk__close" data-close="true" data-select-last="true" aria-label="закрыть галерею"></button>
               </div>
               <div class="gallery-dk__img-wrapper">
                  <div class="gallery-dk__img" aria-labelledby="gallery-dk-description" role="img"></div>
                  <span id="gallery-dk-description" class="gallery-dk__info scroll--v ${descriptionClipped}"></span>
                  
               </div>
               ${list}`;
   }

   destroy() {
      this.#destroyTouchListners();

      this._$el.remove();
      setTimeout(() => {
         this._$el = document.querySelector(this._options.selector);
      }, 1);
   }

   _checkPress(e) {
      if (e.keyCode === this._KEYS.ESC && this._$galleryMainImg.classList.contains("gallery-dk__img--zoom")) {
         this._stopZoom();
         return;
      }
      super._checkPress(e);

      if (e.keyCode === this._KEYS.ENTER) {
         if (e.target.dataset.id) this.setImg(e.target.dataset.id);
      }

      // стрелка вправо и вниз
      if (e.keyCode === this._KEYS.ARROW_RIGHT || e.keyCode === this._KEYS.ARROW_DOWN) {
         e.preventDefault();
         this.nextImg();
      }
      // стрелка влево и вверх
      if (e.keyCode === this._KEYS.ARROW_LEFT || e.keyCode === this._KEYS.ARROW_UP) {
         e.preventDefault();
         this.prevImg();
      }
   }

   _mainElClick(e) {
      super._mainElClick(e);
      // Если по кнопке закрытия
      if (e.target.dataset.id) {
         const id = e.target.dataset.id;
         if (!this._$el.classList.contains("gallery-dk--active")) this.open();
         this.setImg(id);
         this._$galleryMainImg.style.opacity = 0;
      } else if (e.target.closest('[data-next="true"]') || e.target.dataset.next) this.nextImg();
      else if (e.target.closest('[data-prev="true"]') || e.target.dataset.prev) this.prevImg();
      else if (e.target.closest('[data-zoom="true"]') || e.target.dataset.zoom) this._zoomImg();
   }

   open() {
      super.open();
      this.#initOnOpen();
      this._$el.classList.add("gallery-dk--active");
      if (this._$focusableContent.length > 0) this._$focusableContent[0].focus();
   }

   close() {
      super.close();
      this._$el.classList.remove("gallery-dk--active");
      this.destroy();
   }

   // ---------Работа с изображением----------
   setImg(imgNum) {
      this.#activeImgNum = imgNum;

      // Действия с центральным изображением
      this._$galleryMainImg.classList.add("gallery-dk__img--change");
      this._$galleryMainImg.style.backgroundImage = `url('${this._getImgSrc(imgNum)}')`;

      this._getImgBackgroundSize().then((data) => {
         const posEl = this._$galleryMainImg.parentNode.getBoundingClientRect();
         if (data.w < posEl.width && data.h < posEl.height) this._$galleryMainImg.style.backgroundSize = "auto";
         else this._$galleryMainImg.style.backgroundSize = "contain";
      });

      // Действия с листом привью
      if (this._options.imgsList) {
         this._$imgPreviewList.map((img) => {
            img.setAttribute("aria-selected", "false");
         });

         this._$imgPreviewList[imgNum].setAttribute("aria-selected", "true");
         this._$imgPreviewList[imgNum].focus();
      }

      // Действия с описанием
      this._$galleryMainImg.parentNode.querySelector(".gallery-dk__info").innerHTML = this._$originalImgs[imgNum].getAttribute("alt") ? this._$originalImgs[imgNum].getAttribute("alt") : "";

      // Сброс стилизаций и позиций
      setTimeout(() => {
         this._setMainImgStylePos("left", "0");
         this._$galleryMainImg.style.opacity = 1;
         this._$galleryMainImg.classList.remove("gallery-dk__img--change");
      }, 1);
   }

   _getImgSrc(imgNum) {
      let $currentImg = this._$originalImgs[imgNum];
      const imgClass = $currentImg.querySelector("img"); // !Проверяем тэг ли это picture или уже img
      $currentImg = imgClass ? imgClass : $currentImg;

      // Проверяем есть ли дата атрибут для большого изображения
      const dataSrc = $currentImg.dataset.gallery;
      if (typeof dataSrc !== "undefined") {
         const tempImg = new Image();
         tempImg.src = dataSrc;
         if (tempImg.width > 0) return dataSrc;
      }
      return $currentImg.src;
   }

   nextImg() {
      this._setMainImgStylePos("left", -1 * window.innerWidth);

      this.#activeImgNum = this.#activeImgNum++ === this._$originalImgs.length - 1 ? 0 : this.#activeImgNum;
      setTimeout(() => {
         this._setMainImgStylePos("left", window.innerWidth);
         this.setImg(this.#activeImgNum);
      }, this.#ANIMTAION_TIME);
   }

   prevImg() {
      this._setMainImgStylePos("left", window.innerWidth);
      this.#activeImgNum = this.#activeImgNum-- === 0 ? this._$originalImgs.length - 1 : this.#activeImgNum;
      setTimeout(() => {
         this._setMainImgStylePos("left", -1 * window.innerWidth);
         this.setImg(this.#activeImgNum);
      }, this.#ANIMTAION_TIME);
   }
   // ----------------------------------

   // ---------Работа с зумом----------
   _zoomImg(e) {
      let scaleBg = 1.2;
      this._isZooming = true;
      this._$galleryMainImg.classList.add("gallery-dk__img--zoom");
      this._$galleryMainImg.parentElement.classList.add("gallery-dk__img-wrapper--zoom");
      this._$galleryMainImg.style.backgroundSize = "cover";

      const parrentW = this._$galleryMainImg.parentElement.clientWidth - this.#elPadding * 2;
      const parrentH = this._$galleryMainImg.parentElement.clientHeight - this.#elPadding * 2;
      this._getImgBackgroundSize().then((data) => {
         let w = data.w;
         let h = data.h;
         // console.log(data.w > parrentW);
         // console.log(parrentH);
         if (data.w > parrentW * scaleBg || data.h > parrentH * scaleBg) {
            let zoomFactor;
            if (data.w > data.h) {
               zoomFactor = parrentW / data.w;
               w = parrentW;
               h = data.h * zoomFactor;
            } else {
               zoomFactor = parrentH / data.h;
               w = data.w * zoomFactor;
               h = parrentH;
            }
         }
         this._$galleryMainImg.style.backgroundSize = `${w * scaleBg}px ${h * scaleBg}px`;
         if (isTouchDevice()) {
            scaleBg = 2;
            // this._$galleryMainImg.classList.add("gallery-dk__img--touch");
            this._$galleryMainImg.style.backgroundSize = `cover`;
            this._$galleryMainImg.style.width = `${w * scaleBg}px`;
            this._$galleryMainImg.style.height = `${h * scaleBg}px`;
         } else this._startZoom();
      });

      // this._$galleryMainImg.style.backgroundSize = `${parrentW * scaleBg}px ${parrentH * scaleBg}px`;
   }

   _startZoom() {
      this._mouseMoveMainImg = this._mouseMoveMainImg.bind(this);
      this._$galleryMainImg.addEventListener("mousemove", this._mouseMoveMainImg, false);

      this._stopZoom = this._stopZoom.bind(this);
      this._$galleryMainImg.addEventListener("click", this._stopZoom, false);
   }

   _stopZoom() {
      this._isZooming = false;

      if (isTouchDevice()) {
         this.#initTouchListners();
         this._$galleryMainImg.style.width = "";
         this._$galleryMainImg.style.height = "";
         this._$galleryMainImg.classList.remove("gallery-dk__img--touch");
         document.body.style.zoom = "100%";
      }

      this._$galleryMainImg.style.backgroundPosition = ``;

      this._$galleryMainImg.classList.remove("gallery-dk__img--zoom");
      this._$galleryMainImg.parentElement.classList.remove("gallery-dk__img-wrapper--zoom");
      this._$galleryMainImg.removeEventListener("mousemove", this._mouseMoveMainImg, false);
      this._$galleryMainImg.removeEventListener("click", this._stopZoom, false);

      this._$imgPreviewList[this.#activeImgNum].focus();
      this.setImg(this.#activeImgNum);
   }

   _mouseMoveMainImg(e) {
      const posEl = this._$galleryMainImg.parentElement.getBoundingClientRect();

      const stepSizeX = +this._$galleryMainImg.style.backgroundSize.split("px")[0] > posEl.width ? (e.offsetX / (posEl.width - this.#elPadding * 2)) * 100 + "%" : "center";

      const stepSizeY = +this._$galleryMainImg.style.backgroundSize.split("px")[1] > posEl.height ? (e.offsetY / (posEl.height - this.#elPadding * 2)) * 100 + "%" : "center";

      this._$galleryMainImg.style.backgroundPosition = `${stepSizeX} ${stepSizeY}`;
   }

   _getImgBackgroundSize() {
      const imageSrc = this._$galleryMainImg.style.backgroundImage.replace(/url\((['"])?(.*?)\1\)/gi, "$2").split(",")[0];
      const image = new Image();
      image.src = imageSrc;

      return new Promise(function (resolve, reject) {
         image.onload = function () {
            const w = image.width;
            const h = image.height;
            resolve({ w, h });
            // height = image.height;
         };
      });
   }
   // -----------------------------------------

   // ---------Работа с тач событиями----------
   _onTouchStart(e) {
      // Если двайное нажатие
      if (e.touches.length === 1 && this._tapTwiceDetection.bind(this)(e)) {
         // if (this._tapTwiceDetection.bind(this)(e)) {
         if (!this._isZooming) this._zoomImg(e);
         else this._stopZoom();
         return;
      }

      // Если тянут
      this._startDrag(e);
   }

   _onTouchEnd(e) {
      if (this._scaling) this._stopScale(e);
      else if (this._direction) this._stopDrag(e);
   }

   _onTouchMove(e) {
      if (this._scaling) this._onScaling(e);
      else this._dragging(e);
   }

   //  Тянем изображение влево\вправо, вверх\вниз
   _startDrag(e) {
      this._direction = false; // так же служит флагом это события

      this._clickX = e.pageX;
      this._clickY = e.pageY;
      this._$galleryMainImg.classList.add("gallery-dk__img--on-drag");
   }

   _stopDrag(e) {
      // window.removeEventListener("pointermove", this._dragging);
      const closePercent = 0.5;
      const posEl = this._$galleryMainImg.getBoundingClientRect();
      const closePos = posEl.height * closePercent;

      this._$galleryMainImg.classList.remove("gallery-dk__img--on-drag");
      if (this._direction === "left") {
         if (posEl.x < -70) this.nextImg();
         else if (posEl.x > 70) this.prevImg();
         else this._setMainImgStylePos("left", "0");
      } else if (this._direction === "top") if (posEl.y > closePos || posEl.y < -closePos) this.close();

      this._setMainImgStylePos("top", "0");
      this._$el.style.opacity = 1;

      this._direction = false;
   }

   _dragging(e) {
      if (this._isZooming) return;

      const dragX = e.pageX;
      const dragY = e.pageY;
      const dragShiftX = dragX - this._clickX;
      const dragShiftY = dragY - this._clickY;
      // if (Math.abs(dragShiftX) > 20 || Math.abs(dragShiftY) > 20) drag = true;
      if (!this._direction && Math.abs(dragShiftX) + Math.abs(dragShiftY) > 20) {
         if (Math.abs(dragShiftX) > Math.abs(dragShiftY)) {
            this._direction = "left";
         } else this._direction = "top";
      } else {
         if (this._direction === "left") this._setMainImgStylePos("left", dragShiftX);
         else if (this._direction === "top") {
            this._setMainImgStylePos("top", dragShiftY);
            this._makeGalleryTransparent();
         }
      }
   }

   _setMainImgStylePos(direction, shift) {
      this._$galleryMainImg.style.setProperty(direction, `${shift}px`);
   }

   _makeGalleryTransparent() {
      const posEl = this._$galleryMainImg.getBoundingClientRect();
      const transparentPercernt = 0.7;
      const transparentPos = posEl.height * transparentPercernt; // Количесвто пикселей, когда opacity будет 0 (от центра)
      this._$el.style.opacity = 1 - Math.abs(posEl.y) / transparentPos;
   }

   _tapTwiceDetection(e) {
      if (!this.#tapedTwice) {
         this.#tapedTwice = true;
         setTimeout(() => {
            this.#tapedTwice = false;
         }, 300);
         return false;
      }
      e.preventDefault();
      return true;
   }
   //_______________________
   // -----------------------------------------
}

   // ------------------------------------------------------------------------------------

   // -----------Модальное окно-----------------------------
   const humburgerBtn = document.querySelector(".hamburger");
   const logo = document.querySelector(".header__logo");
   const mainNav = new ModalDK({
      selector: ".nav",
      openBtnsSelector: ['.hamburger'],
      collapseOnFocusOut: true,
      onOpen() {
         humburgerBtn.classList.add("is-active");
         humburgerBtn.setAttribute("aria-expanded","true");
         logo.classList.add("header__logo--active");
      },
      onClose() {
         humburgerBtn.classList.remove("is-active");
         humburgerBtn.setAttribute("aria-expanded", "false");
         logo.classList.remove("header__logo--active");
      },
   });
   // ------------------------------------------------------

   // -----------Галерея------------------------------------
   // g = new GalleryDK({
   // selector: ".gallery", // селектор контейнера, который объединяет все изображения
   // focusTrap: true,
   // collapseOnFocusOut: false,
// });
   // ------------------------------------------------------
   // --------------Отправка почты--------------------------
   // 06cc9a6d-ae50-4dfb-ac79-1ec7f4823816 
   const btnSendMail = document.querySelector('#btnSendMail');
   const form  = document.querySelector("#form");
   const sendMail = (e) => {
      e.preventDefault();
      
      if (FormValid.checkValid(form)) {

         btnSendMail.classList.add("msg--sending");
         btnSendMail.setAttribute("disabled", "");
         const removeDone = ()=>{
            btnSendMail.classList.remove("msg");
            document.querySelector(".msg--done").removeEventListener("animationend", removeDone);
            btnSendMail.classList.remove("msg--done");
         }

         // таймаут для "отправки"
         setTimeout(() => {
            btnSendMail.classList.remove("msg--sending");
            btnSendMail.removeAttribute("disabled");
            btnSendMail.classList.add("msg");
            btnSendMail.classList.add("msg--send");
            btnSendMail.setAttribute("data-type", "ok");
         }, 2000);

         // таймаут по которому показываем иконку
         setTimeout(() => {
            
            btnSendMail.classList.remove("msg--send");
            btnSendMail.removeAttribute("data-type");
            btnSendMail.classList.add("msg--done");

            document.querySelector(".msg--done").addEventListener("animationend", removeDone);

         }, 4000);


      // Email.send({
      //    SecureToken : "06cc9a6d-ae50-4dfb-ac79-1ec7f4823816 ",
      //    To : 'danila.korotkov@gmail.com',
      //    From : "you@isp.com",
      //    Subject : "This is the subject",
      //    Body : "And this is the body"
      // }).then(
      // message => console.log(message)
      // );
      }
   }

    if (btnSendMail) btnSendMail.addEventListener("click", (e)=> sendMail(e));
      // ------------------------------------------------------
     
      
   })();
